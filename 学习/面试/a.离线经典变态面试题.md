### 维度建模和范式建模的区别
范式建模遵循三范式嘛,然后他特点就是解耦,同一份数据只存一个地方,让数据不冗余.适合长期稳定的业务

维度建模就简单化,开发周期比较短,面向的是分析,快速想要结果.常见的维度模型就星型模型 星座模型 雪花模型


### 星型模型 星座模型 雪花模型的区别 
星型模型:多为表的数据关系,是由一个事实表去关联多个维表组成,适合大数据的处理,缺点就是会由一定程度的数据冗余,因为会有重复的存储信息

雪花模型:多个维表没有直接连接到事实表上,而是通过其他维表去连接,就会造成一些层次现象,缺点就是会导致查询效率低下,因为会有多Join,不利于开发

星座模型:多张事实表共享维表信息,业务复杂,不经常用

### 上述三个模型的读写效率和存储空间有什么区别
1. 星座模型的读写效率较快,但是存储空间大,雪花模型较慢,但是存储空间小
2. 星座模型适合复杂的业务逻辑,不考虑读写效率和存储空间,能用就好.

### 为什么你们公司要用星型模型


###  OLAP 和 OLTP
OLTP:联机事务处理，主要是对数据库中的数据进行增删改查，操作主体一般是用户。

OLAP:联机分析处理。通过分析数据库中的数据来得出一些结论性的东西。比如给老总们看的报表，用于进行市场开拓的用户行为统计，不同维度的汇总分析结果等等。操作主体一般是运营、销售和市场等团队人员。


### 数据中台
数据中台向是一种机制，加速企业从数据变成价值的一个中间层
数据中台，就是为了弥补数据开发和应用开发之间，由于开发速度不匹配，出现的响应力跟不上的问题

大数据平台提供的是数据加工处理的能力。



### ODS到DWD层的字典码内容转换你们是怎么做的?
建立一张维表然后统一字段,使用的时候做关联就好了


### 一般ODS层到DWD层,任务报错了怎么处理
1. 先去查看hive和spark的web页面或者日志查看报错原因,然后定位解决
2. 如果不是hive和spark的问题,那就是脚本问题


### 有没有遇到过什么业务场景RDD比sql好用的(spark主要用来做什么)
1. 在那种数据源为非结构化数据的时候,我们对数据进行预处理,什么session切割啊,脏数据剔除,字段信息补全,空值填充的时候,sql干不了,RDD就派出用场了
2. 比如我们做归因分析的时候我们也会用到RDD,因为一个用户有可能触发多次目标事件,然后我们在建模的时候就会需要去切分多段来给他打归因权重分



### 事实表有几种 
1. 事务事实表,也就是描述业务过程的事实表,保留的是原子的数据
2. 周期快照事实表,只看某个业务过程,按确定的时间去切分,比如每个月该用户的消费情况
3. 累积快照事实表,也就是一条业务的整个生命周期数据,比如这个人什么时候浏览什么时候点击什么时候下单


### 什么是事实表,什么是维度表,无事实表(事实表和维度表的概念/区别)
事实表是围绕业务过程设计的一个可以被记录的表
维度表是可以以一个合适的角度去聚合主题的表
按我的理解,没有度量的表就是无事实表

### 事实表的设计原则
1.尽可能包含所有与业务过程相关的事实
事实表设计的目的是为了度量业务过程，所以分析哪些事实与业务过程有关是设计中非常重要的关注点。在事实表 中应该尽量包含所有与业务过程相关的事实，即使存在冗余，但是因为事实通常为数字型，带来的存储开销也不会很大。

2.只选择与业务过程相关的事实
在选择事事实，应该注意只选择与业务过程有关的事实。比如在订单的下单这个业务过程的事实表设计中 ，不应该存在支付金额这个表示支付业务过程的事实。

3.分解不可加事实为可加的组件
对于不具备可加性条件的事实，需要分解为可加的组件。比如订单的优惠率，应该分解为订单原价金额与订单优惠金额两个事实存储在事实表中。

4.在选择维度和事实之前必须先生声明粒度
粒度的声明是事实表设计中不可忽视的重要一步，粒度用于确定实表中一行所表示业务的细节层次，决定了维度模型的扩展性，在选择维度和事实之前必须先声明粒度，且每个维度和事实必须与所定义的粒度保持一致。在设计事实表的过程中，粒度定义得越细越好，建议从最低级别的原子粒度开始，因为原子粒度提供了最大限度的灵活性（比如订单粒度无法统计商品粒度的值），可以支持无法预期的各种细节层次的用户需求。在事实表中，通常通过业务描述来表述粒度，但对于聚集性事实表的粒度描述，可采用维度或维度属性组合的方式。

5.在同一个事实表中不能同时存在多种不同粒度的事实
事实表中的所有事实需要与表定义的粒度保持一致，在同个事务表中不能有多种不同粒度的事实。不然对不同粒度的事实进行累加时，其实是会出现很大问题的。

6.事实的单位要保持一致
对于同 个事实表中事实的单位，应该保持一致。比如原订单金额、订单优惠金额、订单运费金额这三个事实，应该采用一致的计量单位，统一为元或分，以方便使用。

7.对事实的null值要处理
对于事实表中事实度量为 null 值的处理，因为在数据库中null对常用数字型字段的 SQL 过滤条件都不生效，比如大于、小于、等于、大于或等于、小于或等于，建议用-9999填充。

8.使用退化维度提高事实表的易用性
在Kimball的维度建模中，通常按照星形模型的方式来设计，对于维度的获取采用的是通过事实表的外键关联专门的维表的方式，谨慎使用退化维度。而在大数据领域的事实表设计中，则大量采用退化维度的 方式，在事实表中存储各种类型的常用维度信息。这样设计的目的主要是为了减少下游用户使用时关联多个表的操作，直接通过退化维度实现 对事实表的过滤查询、控制聚合层次、排序数据以及定义主从关系等。 通过增加冗余存储的方式减少计算开销，提高使用效率。

### 事实表设计方法
1.选择业务过程及确定事实表类型

1.1.选择业务过程:业务过程通常使用行为动词表示业务执行的活动。就拿订单流转的业务过程举例就有四个：创建订单、买家付款、卖家发货、 买家确认收货。在明确了流程所包含的业务过程后，需要根据具体的业 务需求来选择与维度建模有关的业务过程。比如是选择买家付款这个业务过程，还是选择创建订单和买家付款这两个业务过程，具体根据业务情况来确定。

1.2.确定事实表类型:在选择了业务过程以后，相应的事实表类型也随之确定了。比如选择买家付款这个业务过程，那么事实表应为只包含买家付款这一个业务过程的单事务事实表，如果选择的是所有四个业务过程，并且需要分析各个业务过程之间的时间间隔，那么所建立的事实表应为包含了所有四个业务过程的累积快照事实表。

2.声明粒度
粒度的声明是事实表建模非常重要的一步，意味着精确定义事实表 的每一行所表示的业务含义，粒度传递的是与事实表度量有关的细节层 次。明确的粒度能确保对事实表中行的意思的理解不会产生混淆，保证 所有的事实按照同样的细节层次记录。

3.确定维度
完成粒度声明以后，也就意味着确定了主键，对应的维度组合以及相关的维度字段就可以确定了，应该选择能够描述清楚业务过程所处的环境的维度信息。比如在淘宝订单付款事务事实表中，粒度为子订单， 相关的维度有买家、卖家、商品、收货人信息、业务类型、订单时间等维度。

4.确定事实
事实可以通过回答“过程的度量是什么”来确定。应该选择与业务过程有关的所有事实，且事实的粒度要与所声明的事实表的粒度一致。 事实有可加性、半可加性、非可加性三种类型，需要将不可加性事实分解为可加的组件。

5.冗余维度
在传统的维度建模的星形模型中，对维度的处理是需要单独存放在专门的维表中的，通过事实表的外键获取维度。这样做的目的是为了减 少事实表的维度冗余，从而减少存储消耗。而在大数据的事实表模型设 计中，考虑更多的是提高下游用户的使用效率，降低数据获取的复杂性， 减少关联的表数量。所以通常事实表中会冗余方便下游用户使用的常用维度，以实现对事实表的过滤查询、控制聚合层次、排序数据以及定义 主从关系等操作。


--- 

### 项目文档 技术文档用什么维护的
jira 


### 事实表和维度表应该怎么去设计
事实表的设计是以能够正确记录历史信息为准则，用来存储某个主题的主干内容,比如用户创建事件,用户选择点击下单,勾选喜好等行为都属于事实表

维度表的设计是以能够以合适的角度来聚合主题内容为准则,是事实表的补充,比如用户人附近的商圈,什么季度,离最近的节假日等等


###  OLAP 和 OLTP
OLTP:联机事务处理，主要是对数据库中的数据进行增删改查，操作主体一般是用户。

OLAP:联机分析处理。通过分析数据库中的数据来得出一些结论性的东西。比如给老总们看的报表，用于进行市场开拓的用户行为统计，不同维度的汇总分析结果等等。操作主体一般是运营、销售和市场等团队人员。


### 数据中台
数据中台向是一种机制，加速企业从数据变成价值的一个中间层
数据中台，就是为了弥补数据开发和应用开发之间，由于开发速度不匹配，出现的响应力跟不上的问题

大数据平台提供的是数据加工处理的能力。


### 数仓为什么要分层
我会把数仓比作一个很大的图书馆，当书本达到海量的摞在角落的时候，您会发现诶当你想要一个找到一本书的时候，查询会非常吃力，扫描几TB的数据才有可能找到，所以我们可以做几个柜子用空间换时间：通过设立多层次的数据模型来供我们使用，避免我们直接使用操作原始数据，这样我们就可以高效的访问数据。同时可以将复杂的查询分解成单个简单的查询来完成，这样就比较通俗易懂.

1. 降低数据开发成本
例如要计算指标，直接从加工好的数据表中select一下指标值，不管是SQL代码的复杂程度还是查询性能、耗时都要远比再从源表重新清洗一遍业务逻辑要简单的多。

通过分层建设，把通用的业务逻辑加工好，后续的开发任务可以基于模型快速使用，数据需求的响应速度也会更快。

2. 每个数据都有自己对应的作用域
就比如说昨天跑出来两个小时,今天突然五个小时,为什么变慢了我们就可以逐层依赖排查表的情况,去定位问题

3. 方便共享复用，减少重复建设
不同的开发人员、不同时期开发的模型，如果没有分层管理规范，往往导致后期使用时找不到，不是不想复用，而是数据找不到或者需要花费很长时间沟通、翻代码确认，最终耗时反而没有重新写一套逻辑来的快，长此以往，导致大家都不敢用别人的模型，数据复用度低，带来存储和计算资源的浪费。

通过数据分层，将数据有序的管理起来，就像图书馆的书架导航，可以快速帮助使用者找到所需要的书籍在那一层书架中，能找到现成的

4. 增强可扩展性,去屏蔽对业务的影响
如果不分层的话,如果原来的系统业务规则发生变化的时候整个数据仓库就得重新建立,比如说更改某个字段了,那我所有表的字段都得增加,分了层之后就不需要去重新把数据接入了,就只用把字段给补上就好.



### 数仓分层多的优缺点
优点:
1. 数据的血缘关系就会非常清晰,比如某个贴源层的表出问题了,那就可以很快的定位到是哪个表的问题
2. 对数仓上层应用屏蔽了业务系统的异常数据,比如某个贴源层的表异常了,那我数仓种的其中一个模型用到了这个表,那就只用修复这个模型就好了,其余上层的只需要去重跑一遍.
3. 复杂的计算还可以拆分成一步一步的,就可以直接使用中间结果表来搞定,宽表就是个例子

缺点:
1. 画图弄脉络的时候就会很杂乱
2. 分层太多会让数据很冗余,有很多中间表产生



### 说一下传统数仓和大数据数仓的区别
传统数仓基于关系型数据库，主要是用来做联机事务处理的，支持增删改查，支持事务；
大数据数仓基于分布式系统，主要是hdfs，是用来做联机分析处理的，主要是用来进行数据分析的，基本不做增删改查的一些操作

### 对于数据仓库的理解,数据仓库主要为的解决什么问题
我的理解数据仓库就是一个去面对主题的,对业务对企业做决策分析处理的一个分层建设的数据库.它解决了数据的使用效率,就可以很快的很有脉络的拿到数据,而不是乱杂无序的找.然后也可以解决查找大数据量的时候的查询效率,不然跑一个业务要翻遍所有数据,几天都完不成,还有就是可以降低运营的成本吧,本来一大堆人完成的事情,现在几个人就能解决.


### 数仓和数据库的区别
数仓是面向业务和决策的
数据库主要是对事务处理的,对具体的业务做增删改的操作

### 为什么实时数仓不能代替离线数仓
因为实时数仓要保证的实时性,对数据变化是敏感的,他重视的是处理当前的状态,解决的是时效性的问题.
而离线数仓就是去记录历史总结归纳的一个作用,所以他计算量级比较大,计算的时间也会比较场,他们两个的规模就不会相同,而且运维难度也不会一样.

### 数据仓库建设如何应对维度表中的维度描述的变化？
用到了缓慢变化维吧
一般是全量快照存储的方式 或者是以拉链表的形式 
也可以做流水表,改变了就插入新的维度行


### 如果要按guid进行分区的话你怎么设计
把guid前面拼字符串，然后截取字符串对那个字符串进行分区

### 维度退化的理解
维度退化的维度表可以被剔除，从而简化维度数据仓库的模式。因为简单的模式比复杂的更容易理解，
也有更好的查询性能。

当一个维度没有数据仓库需要的任何数据时就可以退化此维度。需要把维度退化的相关数据迁移到事实
表中，然后删除退化的维度。



### 除了维度退化还有什么维度技术 
维度代理键 就是充当维度表主键的一个ID
自然键 员工ID 订单ID
持久键 身份证ID
下钻(增减维度的层次 ) 上卷(删掉维度的某些层) 
维度退化
多层次维度
代替空值属性
角色扮演维度
杂项维度
维度合并
支架维度
分段维度
