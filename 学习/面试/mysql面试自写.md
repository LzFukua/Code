### exists 和 in 的区别 
in 是把外表和内表作hash 连接，而exists是对外表作loop循环，每次loop循环再对内表进行查询。
如果查询的两个表大小相当，那么用in和exists差别不大。
**如果两个表中一个较小，一个是大表，则子查询表大的用exists，子查询表小的用in**

---



### drop delete trancate 区别
drop     把表或者库删除 属于DDL语言
delete   删除表中的数据 属于DML语言
truncate 删除表的所有数据且不可恢复 属于DDL语言 

### mysql服务端如何存储数据的
InnoDB引入了表空间或文件空间的概念。每个表空间被划分为很多个页，表数据就存放在某个表空间的某些页中。
myisam不知道..

### 数据库引擎 innoDB 和 myisam的区别
1. InnoDB支持事务 , myisam不支持
2. InnoDB支持外键,myisam不支持
3. InnoDB是聚簇索引,myisam是非聚簇索引
4. 如果表中绝大多数都是读查询,就可以考虑myisam


### mysql的索引
1. mysql的索引是B+树,因为b+树数据放在叶子节点上,非叶子节点就可以存放更多的索引数据,所以层次会少,那IO就也会少,而且b+树的叶子节点维护了一个双向链表,有利于范围查询
2. 然后InnoDB使用的是聚簇索引,也就是默认使用主键作为索引,因为每个索引下面都是一颗b+树,具有唯一性,物理地址顺序和表的顺序是一样的,查询会快
3. Myisam是非聚簇索引,也就是主键索引和数据分开存储的,和数据没有放在一起.


### B树和B+树的区别
1. B树的中间节点保存节点和数据，B+树的中间节点不保存数据，数据保存在叶子节点中；所以磁盘页能容纳更多的节点元素，更“矮胖”；
2. B树的查找要只要匹配到元素，就不用管在什么位置，B+树查找必须匹配到叶子节点，所以B+树查找更稳定；
3. 对于范围查找到说，B树要从头到尾查找，而B+树只需要在一定的范围内的叶子节点中查找就可以；
4. B+树的叶子节点通过指针连接，从左到右顺序排列；

### mysql 写一条SQL有可能命中几条索引，索引的命中规则是什么
最左匹配原则
1. 先定位该sql的查询条件有哪些，那些是等值的，那些是范围的条件。
2. 等值的条件去命中索引最左边的一个字段，然后依次从左往右命中，范围的放在最后。

### 为什么不使用哈希结构作为索引结构
因为HASH码直接随机生成，并没有规律,导致数据随机分布存储，就会有可能即使是两个很相近的行记录，极大可能也会被分配到不同的桶（磁盘块）中,最坏的情况下每查找一条记录，都要进行一次磁盘IO

### 为什么不使用二叉树作为索引结构
二叉树最多有两个子节点，这种结构导致树的高度会很高，增加IO次数，特殊情况下可能化为链表结构，相当于全表扫描，全量磁盘IO

### mysql b+树索引和hash索引的区别 
1. 哈希索引适合等值查询，但是无法进行范围查询
2. 哈希索引没办法利用索引完成排序
3. 哈希索引不支持多列联合索引的最左匹配规则
4. 如果有大量重复键值的情况下，哈希索引的效率会很低，因为存在哈希碰撞问题

### mysql 写一条SQL有可能命中几条索引，索引的命中规则是什么
最左匹配原则
1. 先定位该sql的查询条件有哪些，那些是等值的，那些是范围的条件。
2. 等值的条件去命中索引最左边的一个字段，然后依次从左往右命中，范围的放在最后。


### 为什么要减少IO
因为磁盘IO要经历两个动作 一个是寻址 一个是数据传输
那一个IO耗时几毫秒 如果数据库是百万级别,那就是几千秒,那就要等到天荒地老,所以用索引的化就能保证数据库过大的情况下只需要几次的IO就可以了


### 索引一定会提高效率吗
不一定 
索引的好处就是 减少IO次数 提高检索效率 降低排序成本减少CPU的消耗

有不少情况会禁用索引，比如！=，not in
数据量小的表可能还不如全表扫描快

索引本身会占空间
Insert/update/delete都需要更新索引 这样速度也会变慢

### 物理结构
顺序存储结构  链式存储结构

### 事务四大特性
1. 原子性
事务的原子性是指事务必须是一个原子的操作序列单元。事务中包含的各项操作在一次执行过程中，只允许出现两种状态之一，要么都成功，要么都失败。
任何一项操作都会导致整个事务的失败，同时其它已经被执行的操作都将被撤销并回滚，只有所有的操作全部成功，整个事务才算是成功完成。

2. 一致性
事务的一致性是指事务在执行不能破坏数据库数据的完整性和一致性，一个事务在执行之前和执行之后，数据库都必须处以一致性状态。
比如：张三给李四转钱，不可能张三被扣了钱，李四没有加钱。

3. 隔离性
事务的隔离性是指在并发环境中，并发的事务是互相隔离的，一个事务的执行不能被其它事务干扰。也就是说，不同事物并非操作相同数据时，每个事务都有完整的数据空间。
一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务是不能互相干扰的。

4. 持久性
事务的持久性是指事务一旦提交后，数据库中的数据必须被永久的保存下来。即使服务器系统崩溃或服务器宕机等故障。只要数据库重新启动，那么一定能够将其恢复到事务成功结束后的状态。
