### 了解JVM吗 说一下
对于我片面的了解来说,JVM就是一台小电脑在我们的操作系统环境,然后他是直接和操作系统进行交互的,不和硬件交互,他包括了一套字节码指令集,一组寄存器,一个栈,一个垃圾回收对和一个存储方法域.

然后JVM的作用就是让java编译的类文件优化完解释给本地系统去执行.

然后JVM的主要组成部分有
1. 类加载子系统:他负责加载class信息
2. 运行区域:也就是JVM的内存
3. 执行引擎:也就是解释命令用的
4. 本地接口:时和其他编程语言交互的接口

然后JVM内存又分为五个区域
1. 程序计数器:就是记录每次执行代码的一个交警,记录线程行号用的
2. 本地方法栈:区别虚拟机调用外部执行方法的
3. 虚拟机栈:是存储局部变量,方法出口,动态连接这种信息的
4. 虚拟机堆:new出来的数组和对象的地方,然后也是GC回收的地方
5. 最后一个是方法区:用来存储常量池,基本类型的变量的地方

然后堆和栈的区别就是
堆是负责管理存储数据的 栈是管理运行的代码的

堆分为堆内和堆外  
堆内分为新生代和老年代
堆外叫做元空间,用的是本地的内存

### GC垃圾回收算法有哪些
常用的好像就
1. 标记清除算法:就是给哪些需要回收的对象像阎王爷一样告诉他已经死了,然后标记完之后就收掉.(也就是把死亡的对象标记为)
2. 标记整理算法:和清除算法一样,但是步骤不太一样,标记清除算法后续的步骤是标记完就直接回收,这会导致如果一个需要一个大的内存款,就没办法得到足够连续的内存嘛,那标记整理就会让活的对象就移动掉一遍,然后清理掉另一边.
3. 复制算法:也就是把内存划分成两个等分,这个不太记得了.
4. 分代收集算法:就是根据对象存活周期的不同把内存分为新生代和老年代,然后就根据你是什么年代采用自己合适的算法.如果你是新生代我就用复制算法,如果你是老年代我就用标记整理算法.

### 新生代和老年代的区别？
我不知道怎么用专业的语言来形容,我就举例子吧,比如我就是一个java对象,诶我出生在了上海浦东新区,然后我在这边会有很多和我一样的新出生的兄弟们,我们就一直都在浦东新区玩,但有一天浦东新区的人已经塞满人了,我就不得已被挤到了黄埔区的FROM区,但我妹有固定的住处了,有时候会在From区,有时候会在To区打拼工作.一直到我年龄到了的时候,我就被分配到养老院,然后再养老院我也遇到了很多老人,接着在养老院生活了一段时间,每次看到有火化厂的工作人员来就证明我老了一岁,老到一定层次就自己也被回收走了.


### 什么是类加载器，类加载器有哪些？
我片面的认为,通过类的名字转换成二进制的一片代码块叫做类加载器
然后好像是有四种类加载器
1. 启动类加载器:用来加载java核心类库，无法被java程序直接引用。
2. 扩展类加载器:它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。
3. 系统类加载器:：它根据 Java 应用的类路径来加载Java 类。
一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它。
4. 用户自定义类加载器，通过继承 java.lang.ClassLoader类的方式实现。
---

### hashMap（无序的）的底层原理
数组+链表+红黑树

### arraylist和linklist的区别
ArrayList： 
适合查询
1. 用数组来实现的
2. 随机访问快（可以根据下标访问）
3. 尾部插入和删除性能可以，头部中间插入删除慢

LinkedList：
适合写入
1. 基于双向链表实现的，所以不需要扩容
2. 随机访问慢（因为它需要迭代遍历）
3. 头尾插入删除性能高，中间插入删除性能慢， 


### String StringBuilder StringBuffer的区别
首先这两个都是对字符串的多次修改的类
他们两个最大的不同是
StringBuilder 的方法不是线程安全的（它不能同步访问）
但是StringBuilder 比 StrirngBuffer要快,因为不需要加锁同步.

String和他们的区别就是,它创建出来就是不可变的一直被销毁为止,就比如给一个String重新赋值的时候他不会给堆中的对象重新赋值,而是生成一个新的对象来引用.
设置为不可变的原因,我片面的认为就是为了让他线程安全加它可以更方便的缓存hashcode.



### 重载和重写区别
重载:指的是一个类定义了多个同名的方法,但是传的参数可以不一样,然后就可以根据传入的参数调用不同的方法

重写:就是这个类去继承另一个类的时候,把他的方法重新写一遍,然后就可以根据自己的特色去定义自己的行为


### java集合有哪些  
list set map

### ArrayList VS LinkedList VS Vector
1. ArrayList基于底层是可变的数组,LinkedList底层是双链表
2. LinkedList的插入添加删除操作速度快,ArrayList读的速度快
3. Vector类似ArrayList,他是线程安全的,然后比ArrayList速度慢,因为有锁,而且每次扩容也会比ArrayList多.


### 哪个结构可以做到检索快增删也快
红黑树/散列表/跳表

### map都有哪些
1. HashMap:可以有一个key为空,value可以都为空,
因为HashMap计算key的hash值时调用特殊的方法会判断key是否为null，如果是则返回0
2. Hashtable: 它不允许记录的键或者值为空
因为它调用的是hashcode方法,如果key为null就抛出空指针.
3. LinkedHashMap:它保存了数据的插入顺序
4. TreeMap:它能够把保存的数据根据键排序

### HashMap底层原理
hashmap是一个存储key-value键值对的集合嘛，然后基于Map的接口实现的，数组就是主干，以数据+链表的结构
JDK1.8之后加入了红黑树，链表长度大于8的时候就变成红黑树了，查询会变快，然后他读写效率比较高，但是读写操作的时候都是没有锁保护的
，所以在多线程的场景下就会不安全。


### Hashmap 和 hashtable的区别
1. 取hash值的方法不同 HashMap是用hashcode取值，hashtable使用特殊的方法重新计算 那最常见的就是null值为0,而hashtable不能有null值
2. 底层数据结构不同 在jdk1.8版本的时候 HashMap底层加了红黑树（数组+链表+红黑树） 而hashtable还是数组+链表
3. hashmap是非线程安全的,hashtable是线程安全的
4. 继承的类也不同 但不太记得了
5. 然后迭代器也不同,hashtable会比hashmap多一种遍历方式叫Enumeration
其他的不记得了

### HashMap和concurrentHashMap的区别
1. Hashmap是数组+链表+红黑树  concurrentHashMap是分段数组+链表+红黑树
2. hashmap底层数组没有加锁 所以非线程安全,concurrentHashMap底层会对具体的节点加锁,所以线程安全



### HashSet去重原理
去重原理，当HashSet add一个元素时，先获取这个元素的散列码（hashcode方法），获取元素的哈希值

情况一：放计算出的元素的存储位置目前没有任何元素存储，那么该元素可以直接存储在该位置上

情况二：如果计算出的位置目前已经有其他元素的，那么会调用equals方法于该位置的元素在比较一次

        如果equals返回值是true，那么说明该元素重复，不允许添加

        如果equals返回值为false，那么说明该元素不重复，那么继续探查下一个位置是否重复，然后重复上面情况



---

### 什么是进程什么是线程
1. 进程:就是一个在内存中运行的应用程序,每次用java命令启动一个java应用程序,就会启动JVM进程.
2. 线程:线程就是一个进程的代码块的一次执行,一个进程至少会有一个线程.每个线程都有自己的计数器和栈,然后他们可以共享堆和方法区.

### 多线程
1. 多进程:每个程序都是一个进程.
2. 多线程:每个进程内部包含了多个线程,然后他们并发的完成自己要做的事.
3. 主线程:在进程中至少存在一个主线程，其他子线程都由主线程开启,主线程不一定在其他线程结束后结束，有可能在其他线程结束前结束。


### 线程池
线程池的底层实现是队列
也就是把待处理任务放入阻塞队列，然后在线程创建后去执行队列中任务。如果任务超出线程数量，则等线程执行完之后再从队列中取出，这样的思想。



### 并行和并发
并行:多个人一起做不同的事
并发:多个人一个时间段都做同件事

### Java创建线程的四种方式
1. 继承Thread类创建线程类
2. 实现Runnable接口创建线程目标类
3. 使用Callable和Future创建线程
4. 通过线程池创建线程

Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已；
Callable接口中的call()方法是有返回值的，是一个泛型，
和Future、FutureTask配合可以用来拿到异步执行任务的返回值。
Callable用于产生结果，Future用于获取结果。

--- 
## 锁
### Volatile（音译va le tou）关键字的作用 (锁)
volatile 关键字的主要作用就是保证变量的可见性然后还有一个作用是和有序性，不保证原子性。
可见性也就是多个线程每次读取到volatile变量，一定是最新的数据，因为一个线程修改变量volatile值之后它就会马上通知其他线程跟着改变。


### synchronized（Sin kue nai si）关键字 (锁)
保证可见性和原子性。
synchronized关键字解决的是多个线程之间访问资源的同步性，可见性。
synchronized关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行，原子性。

### Synchronized 与 Lock 的区别
1. Lock 比 Synchronized 更好用，更灵活。
2. Synchronized 可以自动上锁和解锁； Lock 需要手动上锁和解锁

### Runnable 和 Callable 的区别
1. Runnable 接口中的方法没有返回值； Callable 接口中的方法有返回值
2. Runnable 接口中的方法没有抛出异常； Callable 接口中的方法抛出了异常
3. Runnable 接口中的落地方法是 call 方法； Callable 接口中的落地方法是 run 方法


### 分布式锁
就是分布式的情况下，数据如果只有一份，那就需要利用锁来分配某一时刻修改数据的进程数嘛，
那就用把锁标记公共内存，也就是redis或者数据库
redis > zookeeper > 数据库

### CAS 
简单来说就是如果是预期的值,就和他换,不是就返回false,底层是自旋锁.

### 死锁是什么 
形象的来说就是两个进程在跑的时候,因为A需要B的资源,而B也需要A的资源,然后卡死互相等待的过程.


死锁四个必备条件：
互斥条件：线程独占资源，资源只能供一个线程使用。
请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
不剥夺条件: 线程已获得的资源不能被其他线程强行剥夺，使用完毕后释放。
循环等待条件: 若干进程之间形成一种头尾相接的循环等待资源关系。

### 悲观锁 乐观锁
悲观锁：顾名思义就是我总会假设很坏的情况，认为每次别人拿数据的时候都会修改我的数据，所以我每次让别人拿的时候我都上锁，也就是这个共享的资源只给一个线程，然后等这个线程用完了才转给别人用

乐观锁：就是会去假设最好的情况，认为每次别人拿数据都不会改，所以就不上锁了，但是更新的时候就去看看有没有改数据（可以用版本号机制或者CAS算法）

悲观锁适用于多写的场景
乐观锁适用于多读的场景


---

### IO模型
1. 同步阻塞IO:就是发起连接的用户空间,需要等内核IO操作完成后才到自身的IO
2. 同步非阻塞IO:就是发起连接的他用户空间在等待期间可以做别的事,时不时回来问一下做好了没,会占用CPU
3. 多路复用IO:抽象的来说也就是用户空间叫一个黄牛select来帮他等票,等到有票了他再去取
4. 异步IO:也就是留个缓存地址给内核IO,让他做完IO了将返回值放到这,也就等于自己已经拿到手了

---
### TCP三次握手 四次挥手

三次握手:
1. 客户端像服务端发起连接的时候,会先发一包请求连接的数据,过去问问他现在可以建立连接不,这包称为SYN包,
2. 服务端同意之后,发送一个SYN+ACK包,
3. 客户端收到之后,发送ACK包,此时就已经建立连接

### 为什么是三次不是两次
为了防止客户端发送失败后重发导致的服务端会以为这是建立两次连接导致的不可靠的问题


### 四次挥手
1. 客户端主动发起关闭请求,发送了FIN包,自己处于等待1状态,(第一次挥手)
2. 服务端收到发送AcK包,自己也处于等待1状态,客户端就变成等待2状态(第二次挥手)
3. 此时客户端还可以接受服务端没有发送完的数据
4. 发送完之后,服务端就发个FINK包过去告诉客户端我已经发送完了,自己处于最后等待状态(第三次挥手)
5. 客户端发送ACK包后进入超时等待状态,等一段时间后自己关闭,服务端收到后是立即关闭(第四次挥手)
超时等待是为了防止ACK包没有发送成功导致服务端一直苦苦等待


--- 

### 合并有序数组
思想应该是归并排序这样，也就是用双指针去做

### 二分查找 快排 选择排序 插入排序 归并排序 斐波那契数列
选择排序思想:一个数组内从头部开始找到最小数的与头部进行交换,然后缩短数组,再次循环

冒泡排序思想:一个数组内从头开始两两进行比较并判断是否交换位置,然后每循环完一次大的,就从后往前缩短数组. 因为会找到最大的数在最边上.

插入排序思想:拿起后一个数与前面的所有数进行比较交换位置,直到碰到比他小的才停下.(基本有序的时候效率很高)

希尔排序思想:跨格插入排序的思想,排完一遍再缩小跨格再排

归并排序思想:
将一个数组拆成若干组,每个数字为一组,设立三个指针,两个指针指两个数组开始的位置,一个指针指新数组的位置,于是若干个数组两两开始比较,每被选出来的一个就往前动一个,直到两边比完,多出来的直接赋到上面
然后用到了递归的思想,不断的重复排序合并


快排思想:
选取一个值作为中心点,建立两个左右哨兵,左边动一下右边动一下吗,碰到比中心点大的就移动到右边,小的就移动到左边,直到两个哨兵碰面为止,然后继续将分好的两边区域递归重复同样的操作,直到被拆解得只有一个为止

堆排思想:把无序序列构造成二叉树,然后构造一个大顶堆,从下到上,从右到左的扫描方式依次把最大的数往上移到最顶上,然后取堆顶数字,再把末尾的数继续构造大顶堆,重复操作,直到取完所有的数.


### 同步IO和异步IO 的区别
同步：比如说你发信息给女朋友要求她回电后，不能干别的事情，例如发信息给我。
异步：比如说你发信息给我后，爱干嘛干嘛



### 写一个单例模式懒加载
