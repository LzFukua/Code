### 了解JVM吗 说一下
对于我片面的了解来说,JVM就是一台小电脑在我们的操作系统环境,然后他是直接和操作系统进行交互的,不和硬件交互,他包括了一套字节码指令集,一组寄存器,一个栈,一个垃圾回收对和一个存储方法域.

然后JVM的作用就是让java编译的类文件优化完解释给本地系统去执行.

然后JVM的主要组成部分有
1. 类加载子系统:他负责加载class信息,把这些信息地道方法区中国
2. 运行区域:也就是JVM的内存
3. 执行引擎:也就是解释命令用的
4. 本地接口:时和其他编程语言交互的接口

然后JVM内存又分为五个区域
1. 程序计数器:就是记录每次执行代码的一个交警,记录线程行号用的
2. 本地方法栈:区别虚拟机调用外部执行方法的
3. 虚拟机栈:是存储局部变量,方法出口,动态连接这种信息的
4. 虚拟机堆:new出来的数组和对象的地方,然后也是GC回收的地方
5. 最后一个是方法区:用来存储常量池,基本类型的变量的地方

然后堆和栈的区别就是
堆是负责管理存储数据的 栈是管理运行的代码的

堆分为堆内和堆外  
堆内分为新生代和老年代
堆外叫做元空间,用的是本地的内存

### GC垃圾回收算法有哪些
常用的好像就
1. 标记清除算法:就是给哪些需要回收的对象像阎王爷一样告诉他已经死了,然后标记完之后就收掉.(也就是把死亡的对象标记为)
2. 标记整理算法:和清除算法一样,但是步骤不太一样,标记清除算法后续的步骤是标记完就直接回收,这会导致如果一个需要一个大的内存款,就没办法得到足够连续的内存嘛,那标记整理就会让活的对象就移动掉一遍,然后清理掉另一边.
3. 复制算法:也就是把内存划分成两个等分,这个不太记得了.
4. 分代收集算法:就是根据对象存活周期的不同把内存分为新生代和老年代,然后就根据你是什么年代采用自己合适的算法.如果你是新生代我就用复制算法,如果你是老年代我就用标记整理算法.

### 新生代和老年代的区别？
我不知道怎么用专业的语言来形容,我就举例子吧,比如我就是一个java对象,诶我出生在了上海浦东新区,然后我在这边会有很多和我一样的新出生的兄弟们,我们就一直都在浦东新区玩,但有一天浦东新区的人已经塞满人了,我就不得已被挤到了黄埔区的FROM区,但我妹有固定的住处了,有时候会在From区,有时候会在To区打拼工作.一直到我年龄到了的时候,我就被分配到养老院,然后再养老院我也遇到了很多老人,接着在养老院生活了一段时间,每次看到有火化厂的工作人员来就证明我老了一岁,老到一定层次就自己也被回收走了.




### 什么是类加载器，类加载器有哪些？
我片面的认为,通过类的名字转换成二进制的一片代码块叫做类加载器
然后好像是有四种类加载器
1. 系统类加载器:


### java中线程的实现有几种
1. 继承 Thread 类
2. 实现 Ruunable 接口
3. callable
---
### 进程和线程的区别
我不是很记得了,但是我能抽象一点的方式去说一下,进程就是一辆火车,而线程就是一节节的车厢,线程要在进程下去进行,而且一个进程里可能会有多节车厢的,且如果一节车厢崩了,整个火车都得为它停下来,然后是不同火车共享资源比较困难,而不同车厢共享资源就比较简单

### 死锁是什么 
形象的来说就是两个进程在跑的时候,因为A需要B的资源,而B也需要A的资源,然后卡死互相等待的过程.


### hashMap的底层原理
数组+链表+红黑树

### arraylist和linklist的区别
ArrayList： 
适合查询
1. 用数组来实现的
2. 随机访问快（可以根据下标访问）
3. 尾部插入和删除性能可以，头部中间插入删除慢

LinkedList：
适合写入
1. 基于双向链表，所以不需要扩容
2. 随机访问慢（需要迭代遍历）
3. 头尾插入删除性能高，中间插入删除性能慢， 


### String StringBuilder StringBuffer的区别
首先这两个都是对字符串的多次修改的类
他们两个最大的不同是
StringBuilder 的方法不是线程安全的（它不能同步访问）
但是StringBuilder 比 StrirngBuffer要快,因为不需要加锁同步.

String和他们的区别就是,它创建出来就是不可变的一直被销毁为止,就比如给一个String重新赋值的时候他不会给堆中的对象重新赋值,而是生成一个新的对象来引用.
设置为不可变的原因,我片面的认为就是为了让他线程安全加它可以更方便的缓存hashcode.



### 重载和重写区别
重载:指的是一个类定义了多个同名的方法,但是传的参数可以不一样,然后就可以根据传入的参数调用不同的方法

重写:就是这个类去继承另一个类的时候,把他的方法重新写一遍,然后就可以根据自己的特色去定义自己的行为



### map都有哪些
1. HashMap:可以一个key为空,value可以都为空,
因为HashMap计算key的hash值时调用特殊的方法会判断key是否为null，如果是则返回0
2. Hashtable: 它不允许记录的键或者值为空
因为它调用的时hashcode方法,如果key为null就抛出空指针.
3. LinkedHashMap:保存了数据的插入顺序
4. TreeMap:能够把保存的数据根据键排序


### Hashmap 和 hashtable的区别
1. 取hash值的方法不同 一个是用hashcode 一个使用特殊的方法重新计算 最常见的就是null值为0,而hashtable不能有null值
2. 底层数据结构 在jdk1.8 HashMap底层加了红黑树 hashtable还是数组+链表
3. hashmap是非线程安全的,hashtable是线程安全的
4. 继承的类也不同 但不太记得了
5. 然后迭代器也不同,hashtable会比hashmap多一种遍历方式叫Enumeration
其他的不记得了

### HashMap和concurrentHashMap的区别
1. Hashmap是数组+链表+红黑树  concurrentHashMap是分段数组+链表+红黑树
2. hashmap底层数组没有加锁 所以非线程安全,concurrentHashMap底层会对具体的节点加锁,所以线程安全



### HashSet去重原理
去重原理，当HashSet add一个元素时，先获取这个元素的散列码（hashcode方法），获取元素的哈希值

情况一：放计算出的元素的存储位置目前没有任何元素存储，那么该元素可以直接存储在该位置上

情况二：如果计算出的位置目前已经有其他元素的，那么会调用equals方法于该位置的元素在比较一次

        如果equals返回值是true，那么说明该元素重复，不允许添加

        如果equals返回值为false，那么说明该元素不重复，那么继续探查下一个位置是否重复，然后重复上面情况



### 二分查找 快排 选择排序 插入排序 归并排序 斐波那契数列


### 写一个单例模式懒加载