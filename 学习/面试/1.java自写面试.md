### 了解JVM吗 说一下
对于我片面的了解来说,JVM就是一台小电脑在我们的操作系统环境,然后他是直接和操作系统进行交互的,不和硬件交互,他包括了一套字节码指令集,一组寄存器,一个栈,一个垃圾回收对和一个存储方法域.

然后JVM的作用就是让java编译的类文件优化完解释给本地系统去执行.

然后JVM的主要组成部分有
1. 类加载子系统:他负责加载class信息
2. 运行区域:也就是JVM的内存
3. 执行引擎:也就是解释命令用的
4. 本地接口:时和其他编程语言交互的接口

然后JVM内存又分为五个区域（内存模型）
1. 程序计数器:就是记录每次执行代码的一个交警,记录线程行号用的
2. 本地方法栈:区别虚拟机调用外部执行方法的
3. 虚拟机栈:是存储局部变量,方法出口,动态连接这种信息的
4. 虚拟机堆:new出来的数组和对象的地方,然后也是GC回收的地方
5. 方法区:用来存储常量池,基本类型的变量的地方

然后堆和栈的区别就是
堆是负责管理存储数据的 栈是管理运行的代码的
堆的线程是共有的，栈的线程是私有的

堆分为堆内和堆外  
堆内分为新生代和老年代
堆外叫做元空间(以前叫永久代),用的是本地的内存


### GC回收机制
GC垃圾回收机制，一般在一下情况下会发生：
1. 当Eden区或幸存区（S区）空间不够用时（年轻代）
2. 当老年代空间不够用时
3. 当方法区空间不够用时
4. 手动命令发起GC垃圾回收（ System.gc()命令 ）

GC垃圾回收机制也分两种：
一种是对年轻代的垃圾回收，发生的很频繁且回收速度很快，只要年轻代空间不足，就会发动这种GC
另一种是对老年代的GC，由于老年代的空间要比年轻代的大，且老年代中的对象存活时间很长的对象，因此速度比Minor GC慢很多，发生的次数也很少 

然后GC会去判断哪些对象是垃圾
有引用计数法和可达性分析算法
我只知道可达性分析算法 也就是判断这个对象他可以不可以根据引用链到达GC roots,到达不了就就是不可用的就判断他是垃圾。

GC Roots：程序运行中，一定是活跃的引用对象，如：
1. 虚拟机栈中引用的对象
2. 本地方法栈中引用的对象
3. 方法区静态属性（static）引用的对象
4. 方法区常量（final）引用的对象 


### GC垃圾回收算法有哪些
常用的好像就
1. 标记清除算法:就是给哪些需要回收的对象像阎王爷一样告诉他已经死了,然后标记完之后就收掉.(也就是把死亡的对象标记为)
2. 标记整理算法:和清除算法一样,但是步骤不太一样,标记清除算法后续的步骤是标记完就直接回收,这会导致如果这时候来了一个对象需要一个大的内存,就没办法得到足够连续的内存嘛,那标记整理就会让活的对象就移动掉一遍,然后清理掉另一边.
3. 复制算法:也就是把内存划分成两个等分,这个不太记得了.
4. 分代收集算法(新的):就是根据对象存活周期的不同然后把内存分为新生代和老年代嘛,它就根据你是什么年代采用自己合适的算法.如果你是新生代我就用复制算法,如果你是老年代我就用标记整理算法.

### 新生代和老年代的区别？
我不知道怎么用专业的语言来形容,我就举例子吧,比如我就是一个java对象,诶我出生在了上海浦东新区,然后我在这边会有很多和我一样的新出生的兄弟们,我们就一直都在浦东新区玩,但有一天浦东新区的人已经塞满人了,我就不得已被挤到了黄埔区的FROM区,但我妹有固定的住处了,有时候会在From区,有时候会在To区打拼工作.一直到我年龄到了的时候,我就被分配到养老院,然后再养老院我也遇到了很多老人,接着在养老院生活了一段时间,每次看到有火化厂的工作人员来就证明我老了一岁,老到一定层次就自己也被回收走了.

### 类的实例化过程
类的实例化分两个部分，一个是类的初始化，一个是对象的初始化对吧

那创建类的时候首先需要先加载并初始化类，要创建类的对象实例需要先加载并初始化该类，main方法所在的类需要先加载和初始化；类初始化就是执行<clinit>方法，对象实例化是执行<init>方法；一个子类要初始化需要先初始化父类；类的实例化能够使类的属性赋予到新对象上。

对象的初始化

在方法区加载类；
1. main方法入栈，在栈内存申请空间，定义了一个对象的引用
2. 在堆内存中开辟对象空间，分配对象地址；
3. 在对象空间中，对对象的属性(包括变量、初始化块)进行默认初始化(根据数据类型赋初始值)
4. 构造方法进栈，进行对象属性的显示初始化(程序中定义的初始值)
5. 如果子类的构造方法中使用了super关键字，要执行父类的构造方法，所以就要在执行父类的构造方法之前，先显示初始化父类的属性
6. 初始化完成后，将堆内存中的地址赋给引用变量，构造方法出栈；

### 类的加载过程 
类的加载过程：加载->验证->准备->解析->初始化

加载：通过类的全限定名获取类的二进制字节流，将字节流所代表的静态存储结构转化为方法区的运行时数据结构，在堆中生成一个代表这个类的Class对象，作为方法区中这些数据的访问入口。

验证：主要是确保加载类的正确性，包括文件格式的验证、元数据验证、字节码验证和符号引用验证等。

准备：给类变量分配内存然后设置初始值，注意这里的初始值只是数据类型的默认值而不是代码中被显示赋予的值。

解析：主要是讲符号引用转化为直接引用。符号引用只是用来区分目标的一个代号，直接引用和虚拟机的内存有关，比如指针、相对偏移量等。

初始化：执行类构造器的<clinit>方法，对静态变量和静态代码块进行初始化赋值，这里赋予的是程序中定义的初始值，注意和准备阶段区分。


### 什么是类加载器，类加载器有哪些？
我片面的认为,通过类的名字转换成二进制的一片代码块叫做类加载器
然后好像是有四种类加载器
1. 启动类加载器:用来加载java核心类库，无法被java程序直接引用。
2. 扩展类加载器:它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。
3. 系统类加载器:：它根据 Java 应用的类路径来加载Java 类。
一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它。
4. 用户自定义类加载器，通过继承 java.lang.ClassLoader类的方式实现。

### 什么是双亲委派机制
如果一个类加载器收到了类加载请求，那它首先不会自动去尝试加载这个类，而是把这个类委托给父类加载器去完成，每一层依次这样，所有的加载请求都应该委派给顶层的启动类加载器中，只有当父类加载器反馈自己无法完成该加载请求（找不到所需的类）时，这个时候子加载器才会尝试自己去加载，这个过程就是双亲委派机制！


---


### arraylist和linklist的区别
ArrayList： 
适合查询
1. 用数组来实现的
2. 随机访问快（可以根据下标访问）
3. 尾部插入和删除性能可以，头部中间插入删除慢

LinkedList：
适合写入
1. 基于双向链表实现的，所以不需要扩容
2. 随机访问慢（因为它需要迭代遍历）
3. 头尾插入删除性能高，中间插入删除性能慢， 


### String StringBuilder StringBuffer的区别
首先这两个都是对字符串的多次修改的类
他们两个最大的不同是
StringBuilder 的方法不是线程安全的（它不能同步访问）
但是StringBuilder 比 StrirngBuffer要快,因为不需要加锁同步.

String和他们的区别就是,它创建出来就是不可变的一直被销毁为止,就比如给一个String重新赋值的时候他不会给堆中的对象重新赋值,而是生成一个新的对象来引用.
设置为不可变的原因,我片面的认为就是为了让他线程安全加它可以更方便的缓存hashcode.



### 重载和重写区别
重载:指的是一个类定义了多个同名的方法,但是传的参数可以不一样,然后就可以根据传入的参数调用不同的方法

重写:就是这个类去继承另一个类的时候,把他的方法重新写一遍,然后就可以根据自己的特色去定义自己的行为


### java集合有哪些 
List： List接口存储一组不唯一（可以有多个元素引用相同的对象），有序
的对象
Set: 不允许重复的集合。不会有多个元素引用相同的对象。
Map: 使用键值对存储。Map会维护与Key有关联的值。两个Key可以引
用相同的对象，但Key不能重复，典型的Key是String类型，但也可以是任何对象。

### ArrayList VS LinkedList VS Vector
1. ArrayList基于底层是可变的数组,LinkedList底层是双链表
2. LinkedList的插入添加删除操作速度快,ArrayList读的速度快
3. Vector类似ArrayList,他是线程安全的,然后比ArrayList速度慢,因为有锁,而且每次扩容也会比ArrayList多.


### 哪个结构可以做到检索快增删也快
红黑树/散列表/跳表


### map都有哪些
1. HashMap:可以有一个key为空,value可以都为空,
因为HashMap计算key的hash值时调用特殊的方法会判断key是否为null，如果是则返回0
2. Hashtable: 它不允许记录的键或者值为空
因为它调用的是hashcode方法,如果key为null就抛出空指针.
3. LinkedHashMap:它保存了数据的插入顺序
4. TreeMap:它能够把保存的数据根据键排序

### HashMap（无序的）底层原理
hashmap是一个存储key-value键值对的集合嘛，他的时间复杂度可以达到O1，数组就是主干，以数据+链表的结构
JDK1.8之后加入了红黑树，然后初始数组大小是16，需要扩容的时候就以0.75*数组大小的方式扩容。 
链表长度大于8的时候就变成红黑树了，查询会变快，然后他读写效率比较高，但是读写操作的时候都是没有锁保护的，所以在多线程的场景下就会不安全。

### 你认为HashMap是有序的还是无序的
从我们理解的顺序来看是无序的，因为他不能保证我们插入的顺序，但是它的底层是有序的，因为我们遍历这个HashMap，无论什么时候插入，遍历的时候顺序都是一致的，因为根据Hash算法定位了key的存储位置嘛，只要key是一样的，存储的地方就是一样的。

### hashmap是怎么解决hash冲突(碰撞)的
他是采用那个链式寻址的形式，对于存在冲突的key，他把这个key组成一个单项的链表，后面来的元素就以链的形式加到链表的尾部，然后如果这个过长超过了8，或者是大小大于64，那这个链表结构就转成红黑树，这样查询速度就会变快

### Hashmap 和 hashtable的区别
1. 取hash值的方法不同 HashMap是用hashcode取值，hashtable使用特殊的方法重新计算 那最常见的就是null值为0,而hashtable不能有null值
2. 底层数据结构不同 在jdk1.8版本的时候 HashMap底层加了红黑树（数组+链表+红黑树） 而hashtable还是数组+链表
3. hashmap是非线程安全的,hashtable是线程安全的,因为hashtable大部分修饰普通方法都是 synchronized字段修饰的。
4. 继承的类也不同 但不太记得了
5. 然后迭代器也不同,hashtable会比hashmap多一种遍历方式叫Enumeration
其他的不记得了

### HashMap和concurrentHashMap的区别
最主要的区别是线程安全嘛
1. hashmap底层数组没有加锁 所以非线程安全,concurrentHashMap底层会对具体的节点加锁,所以线程安全，因为他基于CAS加synchronized的，主要是synchronized保证，他给每个数组也就是头结点加锁，就相当于把每个Hash桶锁住了
2. Hashmap是数组+链表+红黑树  concurrentHashMap是分段数组+链表+红黑树


### HashSet去重原理
去重原理，当HashSet add一个元素时，先获取这个元素的散列码（hashcode方法），获取元素的哈希值

情况一：放计算出的元素的存储位置目前没有任何元素存储，那么该元素可以直接存储在该位置上

情况二：如果计算出的位置目前已经有其他元素的，那么会调用equals方法于该位置的元素在比较一次

        如果equals返回值是true，那么说明该元素重复，不允许添加

        如果equals返回值为false，那么说明该元素不重复，那么继续探查下一个位置是否重复，然后重复上面情况



---

### 什么是进程什么是线程
1. 进程:就是一个在内存中运行的应用程序,每次用java命令启动一个java应用程序,就会启动JVM进程.然后进程和进程间都是独立的
2. 线程:线程就是一个进程的代码块的一次执行,一个进程至少会有一个线程.每个线程都有自己的计数器和栈,然后他们可以共享堆和方法区，所以会有可能一个进程内某个线程挂了导致其他线程都出现问题

### 多线程
1. 多进程:每个程序都是一个进程.
2. 多线程:每个进程内部包含了多个线程,然后他们并发的完成自己要做的事.
3. 主线程:在进程中至少存在一个主线程，其他子线程都由主线程开启,主线程不一定在其他线程结束后结束，有可能在其他线程结束前结束。


### 线程池
线程池的底层实现是队列
也就是把待处理任务放入阻塞队列，然后在线程创建后去执行队列中任务。如果任务超出线程数量，则等线程执行完之后再从队列中取出，这样的思想。

主要的作用
1. 降低资源的消耗,可以通过重复的利用已经创建的线程来降低创造线程和销毁线程的资源消耗
2. 提高相应的速度,当任务到达的时候,任务就可以不需要等到线程创建就可以直接执行
3. 

### 线程池有几种
1. FixedThreadPool（有限线程数的线程池）
2. CachedThreadPool （无限线程数的线程池）
3. ScheduledThreadPool （定时线程池）
4. SingleThreadExecutor （单一线程池）
5. SingleThreadScheduledExecutor（单一定时线程池）
6. ForkJoinPool （孕妇线程池）

### 线程池原理以及核心参数
1. 最大线程数 最重要的两个  
2. 核心线程数 最重要的两个
3. 临时线程的单位
4. 临时线程的存活时间
5. 阻塞队列
6. 拒绝策略
7. 线程工厂

原理
我们提交任务的时候，线程池就根据临时线程的大小去创建若干任务数量的线程来执行任务嘛
超过的就去阻塞队列排队，队列也满了就看我们设置的最大线程数创建临时线程，这是会自动销毁的
再超出就根据拒绝策略去对应处理

请求转圈圈

三大方法
1. Executors.newSingleThreadExecutor();
2. Executors.newFixedThreadPool(5);
3. Executors.newCachedThreadPool();

四大拒绝策略
1. AbortPolicy：直接丢弃任务，抛出异常，这是默认策略
2. CallerRunsPolicy：只用调用者所在的线程来处理任务
3. DiscardOldestPolicy：丢弃等待队列中最旧的任务，并执行当前任务
4. DiscardPolicy：直接丢弃任务，也不抛出异常

### 线程池实现任务同步
一、CountDownLatch
同步工具类，允许一个或多个线程等待，直到其他的线程操作完成后在执行。

如何工作：
CountDownLatch是通过一个计数器来实现的，计数器的初始值为线程的数量。每当一个线程完成了自己的任务后，计数器的值就会减1。当计数器值到达0时，它表示所有的线程已经完成了任务，然后在闭锁上等待的线程就可以恢复执行任务。


### 并行和并发
并行:多个人一起做不同的事
并发:多个人一个时间段都做同件事

### Java创建线程的四种方式
1. 继承Thread类创建线程类
2. 实现Runnable接口创建线程目标类
3. 使用Callable和Future创建线程
4. 通过线程池创建线程

Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已；
Callable接口中的call()方法是有返回值的，是一个泛型，
和Future、FutureTask配合可以用来拿到异步执行任务的返回值。
Callable用于产生结果，Future用于获取结果。

--- 
## 锁
### Volatile（音译va le tou）关键字的作用 (锁)
volatile 关键字的主要作用就是保证变量的**可见性**然后还有一个作用是和**有序性**，不保证**原子性**。
可见性也就是多个线程每次读取到volatile变量，一定是最新的数据，因为一个线程修改变量volatile值之后它就会马上通知其他线程跟着改变。


### synchronized（Sin kue nai si）关键字 (锁)
保证可见性和原子性。
它解决的是多个线程之间访问资源的同步性，可见性。
它可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行，原子性。

synchronized关键字最主要的三种使用方式：

修饰实例方法: 作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁
修饰静态方法: 也=就是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员。所以如果一个线程A调用一个实例对象的非静态 synchronized 方法，而线程B需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁。
修饰代码块: 指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。

### 讲下Synchronized锁升级的过程
我记得就是偏向锁 轻量级锁 重量级锁  具体的细节不太记得了

### Synchronized 与 Lock 的区别
1. synchronized是关键字,Lock是接口;
2. synchronized只支持非公平锁,lock支持非公平锁和公平锁;
3. Synchronized 可以自动上锁和解锁； Lock 需要手动上锁和解锁

### Runnable 和 Callable 的区别
1. Runnable 接口中的方法没有返回值； Callable 接口中的方法有返回值
2. Runnable 接口中的方法没有抛出异常； Callable 接口中的方法抛出了异常
3. Runnable 接口中的落地方法是 call 方法； Callable 接口中的落地方法是 run 方法


### 分布式锁
就是分布式的情况下，数据如果只有一份，那就需要利用锁来分配某一时刻修改数据的进程数嘛，
那就用把锁标记公共内存，也就是redis或者数据库
redis > zookeeper > 数据库

### 自旋锁是什么
是指当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环。

### CAS 
简单来说就是如果是预期的值,就和他换,不是就返回false,底层是自旋锁.

一个线程间共享的变量，首先在主存中会保留一份，然后每个线程的工作内存也会保留一份副本。这里说的预期值，就是线程保留的副本。当该线程从主存中获取该变量的值后，主存中该变量可能已经被其他线程刷新了，但是该线程工作内存中该变量却还是原来的值，这就是所谓的预期值了。当你要用 CAS刷新该值的时候，如果发现线程工作内存和主存中不一致了，就会失败，如果一致，就可以更新成功。

### 死锁是什么 
形象的来说就是两个进程在跑的时候,那因为A需要B的资源,而B也需要A的资源,然后卡死互相等待的过程.

死锁四个必备条件：
互斥条件：线程独占资源，资源只能供一个线程使用。
请求且保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
不剥夺条件: 线程已获得的资源不能被其他线程强行剥夺，使用完毕后释放。
循环等待条件: 若干进程之间形成一种头尾相接的循环等待资源关系。

### 遇到死锁问题怎么解决
不可能解决吧，就只能规避掉
那规避的话主要就以那四个必备条件来嘛
第一个互斥条件这个本身就没办法被破坏，因为线程本身就是互斥的，所以就不用管它
第二个就请求且保持的条件，那我们就可以一次性去获取所有资源。
第三个不剥夺条件，我们使这个线程他进一步去申请其他资源的时候，申请不到那他就自己释放掉他自身的资源。
第四个循环等待，因为线程是有序号的嘛，让他们按序号从小到大的去申请。


### 悲观锁 乐观锁
悲观锁：就是我们总会假设很坏的情况，认为每次别人拿数据的时候都会修改我的数据，所以我每次让别人拿的时候我都上锁，也就是这个共享的资源只给一个线程，然后等这个线程用完了才转给别人用

乐观锁：就是我们总会去假设最好的情况，认为每次别人拿数据都不会改，所以就不上锁了，但是更新的时候就去看看有没有改数据（可以用版本号机制或者CAS算法）

悲观锁适用于多写的场景
乐观锁适用于多读的场景

### 公平锁和非公平锁
公平锁：多线程按照申请锁的顺序来获取锁，不会出现争抢的情况。

非公平锁：多线程不会按照顺序获取锁，会先尝试去争抢锁，有可能后面申请的线程比先申请的线程先插队抢到锁，在高并发情况下，可能会造成优先级反转和饥饿的现象。


---
### 线程的生命周期(线程状态)
1. 新生状态 也就是建立了一个线程,这个线程就是新生的状态,然后他有自己独立的内存空间,调用的start方法就进到就绪状态
2. 就绪状态 这时候就等待系统分配CPU给他
3. 运行状态 分配好后就执行自己的run方法,一直到自己死亡为止,如果在给定时间内没结束那就换下来变成就绪状态
4. 阻塞状态 也就是暂时停止了自己的运行,暂时回到就绪队列里面 比如调用了sleep方法
5. 死亡状态 线程死亡的原因有三个，一个是正常运行的线程完成了它的全部工作； 另一个是线程被强制性地终止，如通过 stop 方法来终止一个线程；三是线程抛出未捕获的异常


### IO模型
1. 同步阻塞IO:就是发起连接的用户空间,需要等内核IO操作完成后才到自身的IO
2. 同步非阻塞IO:就是发起连接的他用户空间在等待期间可以做别的事,时不时回来问一下做好了没,会占用CPU
3. 多路复用IO:抽象的来说也就是用户空间叫一个黄牛select来帮他等票,等到有票了他再去取
4. 异步IO:也就是留个缓存地址给内核IO,让他做完IO了将返回值放到这,也就等于自己已经拿到手了

### 同步IO和异步IO 的区别
同步：比如说你发信息给女朋友要求她回电后，不能干别的事情，例如发信息给我。
异步：比如说你发信息给我后，爱干嘛干嘛

同步，可以理解为在执行完一个函数或方法之后，一直等待系统返回值或消息，这时程序是出于阻塞的，只有接收到返回的值或消息后才往下执行其他的命令。

异步，执行完函数或方法后，不勇阻塞性地让它等待返回值或者消息，它只需要向系统委托一个异步过程，然后系统接收到返回值或消息时，它自动触发委托的异步过程，从而完成一个完整的流程。


### 阻塞 和 非阻塞
1. 阻塞，就是调用我（函数），我（函数）没有接收完数据或者没有得到结果之前，我不会返回
2. 非阻塞，就是调用我（函数），我（函数）立即返回，通过select调用通知者

### Thread 类中的start() 和 run() 方法有什么区别？
start()方法被用来启动新创建的线程，而且start()内部调用了run()方法，这和直接调用run()方法的
效果不一样。你调用run()方法的时候，只会是在原来的线程中调用嘛，没就有新的线程启动，start()
方法才会启动新线程。

---
### TCP三次握手 四次挥手

三次握手:
1. 客户端像服务端发起连接的时候,会先发一包请求连接的数据,过去问问他现在可以建立连接不,这包称为SYN包,
2. 服务端同意之后,发送一个SYN+ACK包,
3. 客户端收到之后,发送ACK包,此时就已经建立连接

### 为什么是三次不是两次
他实质上是一个保证接收能力和发送能力的一个保证，就好像是打电话的时候我需要问你你能听见吗，而你说你能听见，同时你也要问我你能听见吗，我回一个我能听见。


### 四次挥手
1. 客户端主动发起关闭请求,发送了FIN包,自己处于等待1状态,(第一次挥手)
2. 服务端收到发送AcK包,自己也处于等待1状态,客户端就变成等待2状态(第二次挥手)
3. 此时客户端还可以接受服务端没有发送完的数据
4. 发送完之后,服务端就发个FINK包过去告诉客户端我已经发送完了,自己处于最后等待状态(第三次挥手)
5. 客户端发送ACK包后进入超时等待状态,等一段时间后自己关闭,服务端收到后是立即关闭(第四次挥手)
超时等待是为了防止ACK包没有发送成功导致服务端一直苦苦等待

### 网络通信协议有哪些 
TCP UDF http https 

### TCP四层网络模型
网络接口
网间层
传输层
应用层


### OSI七层模型
应用层 表示层 会话层 传输层 网络层 数据链路层  物理层 

--- 
### 二分查找 快排 选择排序 插入排序 归并排序 斐波那契数列
选择排序思想:一个数组内从头部开始找到最小数的与头部进行交换,然后缩短数组,再次循环

冒泡排序思想:一个数组内从头开始两两进行比较并判断是否交换位置,然后每循环完一次大的,就从后往前缩短数组. 因为会找到最大的数在最边上.

插入排序思想:拿起后一个数与前面的所有数进行比较交换位置,直到碰到比他小的才停下.(基本有序的时候效率很高)

希尔排序思想:跨格插入排序的思想,排完一遍再缩小跨格再排

归并排序思想:
将一个数组拆成若干组,拆到每个数字为一组,设立三个指针,两个指针指两个数组嘴开始的位置,一个指针指新数组的位置,于是数组邻近的两两开始比较,每被选出来的一个就往前动一个,然后新数组就添加一个,直到两边比完,多出来的直接赋到后面去
然后用到了递归的思想,不断的重复排序合并


快排思想:
选取一个值作为中心点,建立两个左右哨兵,左边动一下右边动一下吗,碰到比中心点大的就移动到右边,小的就移动到左边,直到两个哨兵碰面为止,然后继续将分好的两边区域递归重复同样的操作,直到被拆解得只有一个为止

堆排思想:把无序序列构造成二叉树,然后构造一个大顶堆,从下到上,从右到左的扫描方式依次把最大的数往上移到最顶上,然后取堆顶数字,再把末尾的数继续构造大顶堆,重复操作,直到取完所有的数.

---
### java创建对象有几种方式
1. new一个
2. 反射
3. clone
4. 序列化

### java对象创建过程
1. 首先是JVM遇到一条new对象的指令的时候他就去检查这个指令的参数能不能再常量池种定义到一个类的符号引用.然后加载这个类
2. 接着给对象分配内存,常用的办法是那个 TLAB 本地线程缓冲分配
3. 然后把除对象头外的休对象内存空间初始化

### 反射的实现方式
class.forName（类的路径）
类名.class



### 什么是多态
也就是同一个对象在不同时刻体现出来不同的状态,也就是一个接口多种实现
就比如一个Animal对下个调用叫的方法,就不用对每个子类狗狗猫猫

实现多态的条件
1. 继承：必须要有子类继承父类的继承关系。
2. 重写：子类需要对父类中的一些方法进行重写，然后调用方法时就会调用子类重写的方法而不是原本父类的方法。
3. 向上转型：在多态中就需要把子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。 Fu f= new Zi()

向下转型的意思
所谓向下转型，也就是说父类的对象可以转换为子类对象，但是需要注意的是，这时则必须要进行强制的类型转换。

对于成员变量：编译看左边(父类)，运行看左边(子类)
对于成员方法：编译看左边(父类)，运行看右边(子类)

### 抽象类与接口的区别
1. 抽象类用的是abstact  接口用的是interface  抽象的继承用extends，接口的继承用implements
2. 抽象类是继承的嘛，表示它 是什么东西，接口是实现的嘛，表示它有什么样的功能
3. 一个类可以实现多个接口，但是只能继承一个抽象类


### 能使用反射获得泛型的类型嘛?
不能,因为在运行的期间这个泛型就会被擦除掉,泛型只会在编译的时候检查传入的类型而已.


### Spring IOC AOP
1. IOC就是控制反转嘛，我的了解就是因为以前我们创建对象的主动权都是自己做的，然后现在我们就把这个权利给Spring，然后让他利用反射机制去根据配置文件去创建和管理，也就是说我们创建对象就可以不用去new了。

2. AOP就是面向切面编程，AOP就是通过动态代理的方式，就把那些和业务无关但是又需要去调用那些逻辑的代码给封装起来，这样就可以降低模块之间的耦合度。也就是说我要做一个比如说日志类型的公共代码，放到我很多个业务逻辑上，但这个日志有可能都会需要,那我就把这个日志代码抽象出来变成一个切面去注入到想要加的对象里去完成它。


### 并发情况下读写 双写不一致的问题
读写不一致的问题是在并发的情况下,多个线程对同一个数据同时进行读取和写入的操作导致结果出现问题了嘛,就比如数据库里面我叫张三,然后我缓存也叫张三,但是有线程更改了我的名字变成李四,还没及时更新缓存里的,然后别人读我的名字就有可能还是张三.

双写不一致就是两个线程都是写的操作,然后造成了结果不一致的问题,就比如我存了两百块,我妈妈帮我存了100块,但是账户上就有可能只加了一份钱,然后出了两个结果.

解决的方式就是用分布式锁.


### http 错误提示
401: 用户没有访问的权限,需要身份认证
403: 禁止访问的意思,表示服务器已经理解请求,但是拒绝执行它
404: 表示请求失败，请求所希望得到的资源没有被在服务器上找到
405: 不允许使用请求行中所指定的方法