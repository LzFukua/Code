doris 设置了两种角色 FE  BE

FE存储和维护集群的元数据 
有三类子角色
1. leader 
2. follower
3. observer  只用来扩展查询节点

BE 负责物理存储和计算
每个BE会存储副本 像分区一样 可以动态扩容和缩容 增加存储能力和计算能力
最好用下线的方式让BE减少 而不是删除 否则会将数据也连带删除且不能恢复

FE至少三个 保证高可用  如果在高可用的基础上因为查询压力过大,就增加observer的节点,因为Observer就是负责分担的

doris的底层存储引擎中,物理上是以桶为单位进行存储管理的
每个分桶就是一个数据分片 tablet 数据划分的最小单元 

doris的分区是管理单元 并不是物理单元 如果要删一个分区 这个分区的tablet都会被删掉

允许用户表创建好之后,人工添加新的分区定义
也允许用户定义动态分区,后台启动一个定时任务,周期性的执行创建新分区以及删除指定的分区

一个表的tablet数量要略多于或者等于整个集群磁盘数量
且单个tablet的数据量最好在1-10G范围
这样就不会让一个磁盘的IO负载大,元数据管理压力大,如果过大了就不利于副本的迁移和补齐    



一个分区的桶数一旦指定了就不能改变,只能重新建一个然后传进去,再将原来的删除

所以一定要写distribute by   可以不写partition by 


表模型 
Aggregate    聚合模型
Unique       去重数据模型
Duplicate    可重复数据模型

1. Aggregate 
key value 
对value进行聚合 有求和 替换 Max min 

数据的聚合
1. 每一批数据导入的ETL阶段都会进行一次聚合  
2. 底层BE进行异步数据combine合并阶段,会进一步的聚合
3. 数据查询时候也会进一步聚合  

2. Unique 
key value  key唯一 就会替换值

3. Duplicate 
key value 设计key为了排序,也为了查询的时候速度快 
声明数据也要跟key顺序一致

roll up 表
维度 : 省\市  
自动上旋 后面的数值 1000 800 600 
但是会有具体的占用物理空间  每个表都会占用
空间换时间

会自动匹配roll up的表  前提是需要让聚合字段也要放在roll up修改表语句里
但如果是Duplicate的roll up 那没有上卷的效果 有了索引优势


索引 

1. 前缀索引和ZoneMap索引 
2. 内建的用户创建的二级索引,布隆过滤器和bitmap等

前缀索引在排序的基础上去给定前缀列来达到索引的能力.
ZoneMap索引是在列村格式上,对每一个列自动维护的索引信息,相当于数据块的元信息,能判断聚合比如Max/min然后快速定位.

基数 去重后的个数 
高基数列 去重后值还很多的
低基数列 去重后值就几个的

doris导入数据  尽量不要使用insert into 因为会产生很多小文件
1. StreamLoad 通过http协议去Doris进行交互连接
2. 从HDFS导到doris表中

基本原理: 
提交导入任务后,FE会生成计划,将任务分配给BE,BE在执行的过程中从Brokers拉取数据,再对数据转换之后导入到存下来


### clickhouse与Doris的区别
Doris
使用更简单，如建表更简单，SQL标准支持更好， Join性能更好，导数功能更强大
运维更简单，如灵活的扩缩容能力，故障节点自动恢复，社区提供的支持更好
分布式更强，支持事务和幂等性导数，物化视图自动聚合，查询自动路由，全面元数据管理

ClickHouse
性能更佳，导入性能和单表查询性能更好，同时可靠性更好
功能丰富，非常多的表引擎，更多类型和函数支持，更好的聚合函数以及庞大的优化参数选项
集群管理工具更多，更好多租户和配额管理，灵活的集群管理，方便的集群间迁移工具

