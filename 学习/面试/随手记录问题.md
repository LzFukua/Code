
### 行存储和列存储的区别
（行式存储相当于套餐，即使一个人来了也给你上八菜一汤，造成浪费；列式存储相等于自助餐，按需自取，人少了也不浪费）
传统行式数据库的特性如下：
1. 没有索引的查询使用大量I/O。比如一般的数据库表都会建立索引，通过索引加快查询效率。
2. 建立索引和物化视图需要花费大量的时间和资源。
3. 面对查询需求，数据库必须被大量膨胀才能满足需求。

列式数据库的特性如下：
1. 数据即索引。
2. 只访问查询涉及的列，可以大量降低系统I/O。
3. 每一列由一个线程来处理，即查询的并发处理性能高。
4. 数据类型一致，数据特征相似，可以高效压缩。

行存储应用场景
关注整张表内容，或者需要经常更新数据
需要经常读取整行数据
不需要聚集运算，或者快速查询需求
数据表本身数据行并不多
数据表的列本身有太多唯一性的数据


列式存储应用场景
基于一列或比较少的列计算的时候
经常关注一张表某几列而非整表数据的时候
数据表拥有非常多的列的时候
数据表有非常多行数据并且需要聚集运算的时候
数据表列里有非常多的重复数据，有利于高度压缩

行存储的写入是一次性完成，消耗的时间比列存储少，并且能够保证数据的完整性，缺点是数据读取过程中会产生冗余数据，如果只有少量数据，此影响可以忽略;数量大可能会影响到数据的处理效率。

列存储在写入效率、保证数据完整性上都不如行存储，它的优势是在读取过程，不会产生冗余数据，也就是我需要读什么数据我就不会多读别的,所以只针对某几个字段的读取效率会比较高


### MPP数据库
greenplum doris

### SpringBoot 三层
dao 层 底层逻辑 做一些增删改查的操作
Server层处理业务逻辑 
controller层 负责请求转发，接受页面过来的参数，传给Service处理，接到返回值，再传给页面


### 有1个G的文件,只有1M的运行内存,怎么处理求出出现次数前100的数据?
先遍历1G的大文件，按照Hash%1000取模将大文件映射成1000个小文件，保证了相同的词分到同一个小文件中，这样每个小文件大概1M大(也可以分多些小文件，这样每个文件大小就更小)，就可以放入内存中。在每个小文件中使用Hash_map，以单词为key，出现的次数为value，然后用最小堆得到每个小文件出现频数最多的100个单词，最后归并排序，就可以得到了




### 你使用过的数据库优缺点，在项目上为什么要这么使用
首先说这个实时项目上的
Hbase是我们之前使用的 我们是用guid做rowkey来打标签嘛，他可以存储庞大的数据量，但是Hbase的维护成本有点高因为涉及到的组件比较多，而且致命的问题就是我们这个项目是需要做到模糊查询的，而Hbase只能根据rowkey查询。

那我们用ES是因为他可以做到模糊查询，而且它支持的查询功能是比较丰富的，做一些词汇的复杂查询是完爆Hbase，就比如可以做到match的语句模糊查询，indices权重比查询，还有一些什么位置信息五公里内的查询，还有就是ES他自成一个体系的嘛，维护起来就稍微好一些。

然后Doris是因为他相比于ClickHouse的话
1. doris维护成本更低一些,不需要太大的集群规模,运维也简单,社区更活跃一些
2. doris上手也比较简单一些,sql都是标准化的,然后我们暂时也不需要那么多的函数 

但如果我们的规模做大了的话，ClickHouse集群一旦多了就可能会比Doris更厉害一些，因为他自身的功能会比较多，函数也比较多。

Redis的话
1. redis对外开放，需要对运算结果或初始值等进行人为干预的话，很方便
2. redis中有丰富的数据结构，因为中间聚合结果的数据结构会有差别,我们要拿这个状态与未来在线运算的相结合嘛,这也会为我们的滚动增量运算逻辑设计带来潜在的帮助
3. redis本身的读写速度与flink内部的state不相上下，可以满足我们的高并发低延迟读写要求,也仅仅只是丢失一丢丢checkpoint回滚的特性,但我们不用去计较这种错误,最多造成的也只是他获得了一个我不该发的优惠券而已,没必要去为了精度丢失掉时效性就或者性能

再到MySql 他是我们用来做业务库的 因为他是免费的嘛 而且轻量级 市面上应该是最好用的关系型数据库，适用于增删改，缺点就是对于大数据量的时候处理效率就会很慢，而且不支持OLAP功能。


### Shuffle的作用是什么
因为我们处理大数据之前需要做到分区的操作对吧，也就是分而治之的思想，但由于每个分区所承担的数据都是不统一的，我们需要得到统一的数据就需要将每个分区的数据取出来重新整合分类，让他比如每个key都到一个分区里面，这就是shuffle的作用。

### shuffle中的合并操作
shuffle的合并就是为了解决后续的网络压力以及单一的Reducer压力


### HDFS并发写入
最开始的设计思路是：用互斥锁来实现。即某一个时刻，只有拿到互斥锁的客户端能够执行写操作。但是，互斥锁在分布式系统中会有很多问题。
问题一：客户端每次执行写入时，都需要向namenode申请互斥锁，这样会增加不必要的网络通信开销，浪费宝贵的网络带宽资源。
问题二：假如某个客户端拿到互斥锁之后，失去了和namenode的联系，则可能会出现此客户端的持有的互斥锁永不释放的情况，造成死锁。从而造成其他客户端的操作被终止。

HDFS采用了租约机制（Lease），Lease就是一个有时间约束的互斥锁，即某一个客户端成功拿到租约锁后，在租约有效时间内，此客户端一直持有文件写权限。（其他客户端等待）

租约过期后，如果此客户端的文件还没写完，则向NameNode申请续约。
此外，如果此客户端在租约的有效期间内，客户端发生了异常，和NameNode失去了联系，当租约期满后， NameNode会发现发生异常的客户端，此时NameNode会将新的租约赋给其它正常的客户端，而发生异常的客户端已经写入的那部分数据会根据其对应的数据版本号被安全删除掉。

在LeaseManager这个类有两个变量：softLimit和hardLimit，用long来约定两个时间期限。这两个变量的意思分别是：软限制和硬限制。

softLimti的释义：比如申请一个租约时间是 10s，softLimit是3s，如果一个客户端上传一个文件，已经用时10s，但还没上传完，那还可以再用时3s来继续上传，如果过来3s之后还没上传完，就申请续约（再申请10s的租约）。

在LeaseManager这个类里有一个Monitor线程，这个线程会周期性检查（hardLimit）是否过期。如果过期，就强制收回租约，并分配给另一个新的客户端。hardLimit释义：比如申请一个租约时间是10s，hardLimit是3s。如果一个客户端上传一个文件，用时2s就传完了，文件的输出流close。close之后过了3s，（此时租约还有5s未用完）namenode强制收回租约，交给其他新的客户端。

