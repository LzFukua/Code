kafkaAPI  
必须要配置 Bootstrap 服务器地址 以及 key value 的序列化器 其他可选 
且必须要kafka的序列化器 不可以用jdk或别的 

生产者可以根据自己逻辑发往自己想到的topic






kafka
1. 手动指定了起始位置 它肯定从你指定的位置开始
2. 如果你没有手动指定起始位置 它去找消费组之前所记录的偏移量开始
3. 如果之前的也获取不到,就回去看参数的重置策略

subscribe自动订阅 是需要参与消费组的再均衡机制才能真正获得自己要消费的topic及其分区的
(如果用subscribe订阅主题,就不要去seek偏移量,如果非得seek,就不要参与消费组的再均衡)
可以用cunsumer.assign() 
subscribe 自动订阅 
assign 手动订阅


kafka2.4.1之后 再分配机制就有了Cooperative 只让渡需要让渡的分区 不需要将所有的都停止

kafka分配策略
range 分配: 每个topic除以2 然后平分  这会导致前面的那个永远是多的
round分配 : hashCode打乱之后轮询方式分配
Sticky分配 尽量保留之前分配好的分区 不会去重新打乱 但是还是会取消所有再分配
Cooperative分配  这个就会一个个取消 消费者不用取消所有分区,只需要反馈自己的分区信息,然后Cooperative就会去找zookeeper获取元数据来得到本组订阅的主题有哪些分区,然后根据策略算法去让某分区停止获取,然后再去发送再均衡通知,再让新加的消费者去负责该分区    


消费者组的再均衡流程 (分的过程)
1. Group Coordinator 组协调器
2. Group Leader (组长) 位于消费端的某个消费者

--consumer_offset这个topic是用来专门记消费位移的 有50个分区

每一个消费组,记录的消费偏移量,是会记录在_consumer_offset的固定分区中
拿着组ID(--group xxx) % 分区数 
如果为0 就发到 0号分区



x组的协调器是哪台broker?
就是x组写消费位移上述分区的leader副本所在的broker 
(通俗一点说就是 我们组50%为0组的话,我们组就是往0号分区记偏移量,但0号分区的leader为1号的话,我们组协调器就在1号broker,消费者leader随机选取,然后选取分区分配策略,leader就根据策略的算法去分配各自负责哪个分区,然后就心跳通信)


eager协议再均衡整体过程(特点为:再均衡发生时候,所有消费者停止工作,等待新方案的同步)
原来消费者组的人通过心跳与组协调器联系,此时有新人通过心跳请求加入,组协调器就会往原来消费者组发送要求再均衡通知,(然后取消所有分区),然后去选举分区分配策略,将选举好的策略广播给所有消费者,然后所有消费者再和组协调器建立心跳  

Cooperative协议
与上述不同为,消费者不用取消所有分区,只需要反馈自己的分区信息,然后Cooperative就会去找zookeeper获取元数据来得到本组订阅的主题有哪些分区,然后根据策略算法去让某分区停止获取,然后再去发送再均衡通知,再让新加的消费者去负责该分区    


实时流式处理 
bitmap初始化就10亿个扩容
而hashMap按需要扩容,一次性扩一部分 
roaringbitmap工具包,就是基于bitmap思想所开发的一个数据结构工具,它底层会对最原始的Bitmap存储结构进行优化 


