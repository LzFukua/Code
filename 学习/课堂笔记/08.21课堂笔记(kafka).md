生产者只能存数据到leader 消费者也只能从leader去取数据

kafka的整体存储结构
1. 稀疏索引
2. timestamp稀疏索引
3. log文件
4. 纪元号-leader-checkpoint


消息message存储结构
key value 的数据和数据长度
时间戳
校验消息
kafka版本号 
(随着版本号变动过,里面东西越来越多,我只记得一部分,剩下的忘了)  


日志切分的条件
1. 日志文件大小超过1G
2. 日志分段的最小时间戳与当前时间超过7天
3. 偏移量文件10M
4. 追加的消息偏移量与当前日志分段的起始偏移量的插值大于正数的最大值 


topic的每个分区的每个副本,及其leader副本,在集群中如何分布的?
策略1:kafka自动分布
策略2:手动指定

leader副本是随机选的 其他leader副本依次往别的broker顺序发放
其他follow副本都是随机数发放
1. 副本是不会转移的
2. leader是动态选举的
3. leader的选举策略就是按ISR列表中的第一个



topic的各分区副本的分布,以及leader副本的选举,是谁在控制?
分布策略控制和分区leader副本的选举,由**控制器Controller**(也就是某个broker,且只有一个)来控制
谁先来谁当控制器,如果本台控制器挂了,就谁先去zk上抢注谁就当

但有可能造成leader挤一堆去
但是可以控制器会定期的负责动态均衡,更换leader位置


与组协调器不同的是,组协调器是每个broker都可能会充当某些副本的协调器,用作消费者副本分配策略的 控制器是控制整个集群的只有一个

生产者有个很重要的参数 叫 ACK应答级别
1. ACK是干嘛的 
ACK是控制kafka服务端如何向生产者确认消息写入成功的

2. ACK有哪几种值 分别有什么特点  -1/all  0 1
   1. 1 表示leader保存成功这条消息才向生产者应答成功(写到log日志文件里了才算)
   2. 0 表示producer压根不等待确认消息直接发送
   3. -1/all 表示leader及所有的ISR副本全部保存好呃才向生产者应答成功
3. 如果选了-1写入速度已经跟不上了,且生产端出现了数据积压,只能增加分区增加并行度去完成
但是-1也不一定保证数据不丢失,因为当leader挂掉而未同步的机器正在当选leader,就会以该leader为基准

min.insync.replicas 最小副本数  必须保证集群至少有几个副本


kafka生产者的数据发送流程 (写流程)
1. 调用kafkaProducer send方法
2. 将数据传入拦截器对消息进行过滤或者加工处理
3. 将消息传入序列化器
4. 然后分区器去发送到消息累加器里面进行分区缓存
5. 另一个sender线程不断从缓存区取数据出来
6. 创建requester网络请求,一边发送到selector去连接broker发送,一边做缓存
7. 如果发送失败了,就可以从缓存区里重试发送
8. 如果发送成功了,就清除缓存 

生产者
producer的重试机制,有可能会造成数据的乱序,还有可能造成服务端的重复(可开启幂等性(就是一个操作重复做,也不影响最后的结果))

默认分区器的分区规则为 如果数据中有Key,则按key的murmur2hash%topic分区总数得到目标分区
                      如果数据只有value,则在各个分区轮询发放

kafka生产者可以设置压缩数据




消费者
再分配机制的触发条件 
1. 消费者增减
2. 订阅的主题,分区发生了增减
3. 组协调器发生了变更

consumer的消费位移提交方式 
1. 全自动 开启 auto.offset.commit 
2. 半自动 关闭 auto.offset.commit 然后手动触发 consumer.commitSync() 会去__consumer_offset去找偏移量
3. 全手动 关闭 auto.offset.commit 写自己的代码去把消费位移保存到自己的地方  mysql/redis 提交到自己所设计的存储; 初始化也需要从自定义存储中查询到消费位移
consumer的自动消费位移提交机制所可能发生的问题  会读重
所以我们要目标是精确到只有一次

解决数据重复问题,有两种办法 1. 幂等性 2. 事务


mysql 的 upsert功能 
语句为 insert into xxx values(id,name) on duplicate key update name = ?
如果新加入的数据主键重复则更新 name 
如果新加入的数据不重复主键 则往下添加一行

起始位置初始化,接续
要考虑两个环节
1. 程序启动的起始位置初始化
2. 程序正常运行过程中发生了消费组再均衡时,也需要进行起始位置的重新初始化


